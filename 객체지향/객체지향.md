# 객체지향이란?(프로그래밍 패러다임의 역사&개선 관점)
  * 비구조적 프로그래밍(lowlevel - 어셈블리어, highlevel) : CPU와 기계에는 최적화 되어있는 언어이지만, 절차나, 구조가 없고 goto의 남용으로 기계에만 최적화되어있음(사람이 이해하기 어려움)
  * 절차적 프로그래밍 : 어셈블리어(low-level), 포트란(high level) 언어의 goto 남용과, 스파게티 성 코드의 단점을 제거하기 위해, 데이터 구조체와 절차적 코드가 등장
  * 구조적 프로그래밍 : 데이터들을 하나의 구조체로 관리하기 시작. 함수단위로 나누기도 했음. 
    하지만 <B>"하나의 작업"</B>을 진행하기 위해, 작업을 나누는 <B>하향식 방식</B>이어서, 다양한 작업을 해결하기에는 적합하지 않음.(하위 method, 반복문, 선택문등이 한 작업에 종속되어 있음.)
  * 객체지향 프로그래밍 : 상향식 프로그래밍 해결법으로, 하나의 작업에 종속되지 않도록 했다.(이때 캡슐화, 메시징, 동적 바인딩의 개념이 사용된다.) 
    객체를 미리 정의하고, 객체간의 메시징, 바인딩으로 사용자가 사용하기 편하도록 하여, 대규모 시스템에서 분업 작업, 유지보수를 하기에 적합하다.
    또한, 객체지향은 본질(메세징, 캡슐화, 동적(늦은) 바인딩)외에 계속 방법론들이 발전하면서, 다양한 정의와 설계 방법들이 등장하였다.
    대규모 시스템이 많은 지금 많은 엔터프라이즈 기업 또는 대규모 서비스에서 개발 방법으로 사용되고 있다.


# 객체지향은 왜나왔을까?(구체적으로)
  * 통으로 되어있넌 프로그램(일체형 혹은 한 작업에 종속)되어 있던 프로그램을 <B>분리</B>히여 개발하기 위해 나왔다.

# 객체지향은 무엇을 분리로 어떤 이점을 가질까?
  * 가게에서 1명의 직원이 모든 것을 잘 처리할 수 있겠지만, 손님의 수가 많아지고 가게가 확장되면, 아무리 뛰어난 1명도 벅차기 마련이다.
  * 이럴때, 필요한 것이 분리, 분업 등이다. 이때, 분리를 함으로써 더 큰 작업과 일들을 처리할 수 있다.
  * 이것을 프로그래밍 관점에서 보면, 일체형프로그램을 2개로 분리하면서 큰 작업에 대응할 수 있다.
    * 여기서 직원을 더 쓰기 위해, 2개의 객체라는 개념이 필요하고, 객체는 캡슐화시켜, 각자의 역할을 분명히 나누도록 한다.(전역데이터는 혼동을 초래) 
    * 이 객체들이 협업하기 위해서는 서로에게 요구사항을 요구할 메세지가 필요해진다.(인터페이스)

# 분업과 소통(메세징)을 효율적으로 하려면 어떻게 해야할까?
  * 객체를 적절하게 나누어야한다. 객체의 역할과 책임을 명확히 정의하고, 어떤 협력 프로세스로 작업을 설계해야 좋을지 고민해야한다.
    * 협력 프로세스는 가게에서 1명의 판매원이 2명이나 3명이 된다고 효율적이어지는 것이 아닌 것처럼. 각자 분업을 잘해야하고, 프로세스도 잘 정의 하여야한다. 이런 것들이 객체제 적용되어야 한다.

# 객체지향의 장점
  * 유연하게 시스템을 바꾸기 쉽다.(동적 바인딩, 추상화, 캡슐화, 메세징 등)
  * 전체시스템을 파악하기 쉽다.(구현체까지 접근하지않고, 추상화된 인터페이스만 봐도 시스템을 이해할 수 있다.)


# 객체지향의 본질 3가지(앨런케이)
  * 캡슐화
    * 데이터를 보안적인 측면에서 숨기고, 역할을 분명하게 나눌 수 있도록 하는 특징
  * 메시지
    * 캡슐화된 객체에게 요청을 하기 위해 필요한 메세지, 객체를 호출하기 위해, 객체를 추상화하여 메시지만 알아도 호출되도록하기 위해 사용된다.
  * 동적 바인딩
    * 설계 단계에서부터, 호출 부분이 구체적인 단계를 이해하지 못해도 되도록 만드는 개념(내부는 객체를 갈아끼우거나, 확장하기 편하도록, 유지보수하기 쉽도록 만들어짐)
    * 동적 바인딩 예시 KakakoLoginService.isUser(userName) -> return true/false 인 경우 -> 애초에 KakakoLoginService.isUser가 아니라, 추상화 되어있어서 isUser(name)만 사용하여도, 내부에서는 KakakoLoginService, NaverLoginService, GoogleLoginService 등으로 알아서, 파라미터 값에 따라 바인딩 된다거나, 특정 유저의 패턴으로 해당되는 서비스에서 유저를 찾도록 하는 것이 동적 바인딩이다.
    * 동적 바인딩을 사용하면 AmazonLoginService 소스를 추가할때, 호출부는 아무런 변경이 없어도 된다.(인터페이스 설계 규칙만 제대로 정의되어있다면) 이런 장점들이 객체의 메시징과 캡슐화가 잘되어있으면 더 동적바인딩을 하기 쉽다.
    * 즉 KakaoLoginService, ArrayList 등 수신자를 직접지정하지 않아도, 다형성이나, 혹은 전략패턴같은 추상화된 상태에서 사용이 가능하다는 것이다.

# 추가적으로 프로그래밍 패러다임의 차이점
  * 절차형 프로그래밍 : 모든 필드와 데이터가 선언되어있으며, 데이터가 노출되어있다. (캡슐화 없음)
  * 객체지향형 프로그래밍 : 필드와 데이터들이 각각 객체안에 선언되어있으며, 데이터가 노출되어있지않다.( 캡슐화)
  * 절차형 프로그래밍은 <B>작업을 한단위 한단위로 추가하고, 이해하는데에는 오히려 유리할 수 있으나</B>, <B>분리하여 이해하는데에는 어려움</B>이 있다.
    * 즉, 절차형 프로그래밍은 작업 단위로 추가하는 소규모 프로젝트나, 중요한 작업을 몇개만 사용하는데에는 오히려 유리할 수도 있다.(확장가능성이 없는경우)
    * 객체지향형 프로그래밍은 작업 단위(하향식)가 아닌, 객체를 조합하여 작업을 만드는 행위(상향식)이기 떄문에, 절차지향에 있는 method, data와 객체지향에 있는 method, data는 모습은 똑같지만 사용되는 개념이 다르기 때문에, 재사용성 측면에서 다른 방향을 나타낸다.
    * 절차지향 method, data(작업에 종속) / 객체지향 method, data(객체에 종속) but, 객체는 작업에 종속되어있지않음.