# 자바의 신 1
 # 1장(프로그래밍 기본)
  * Class에는 상태(변수)와 행동(Method가 존재해야 한다.)
 # 2장(자바의 실행 과정)
  * 소스 -> 컴파일러 -> 바이트 코드 -> 디스크 -> 바이트 코드 -> JVM -> 기계어 -> 운영체제
  * 각각 명시하는 단어들이 정확히 무엇을 가리키는지.(그리고 1depth 추가하여 읽기), 1depth 추가 키워드 : 컴파일러, JVM, 디스크, 바이너리, JAVAC란?
  * .Class를 명시하지않아도 자기가 알아서 찾아줌.
  * 주석(한줄, 블록, 문서용(java docs도 찾아보기))
 # 3장(자바와 객체지향)
  * 상태(순간의 모습), 행위(연속적으로 동작되는 행위)
  * 기본생성자는 만들어지기 때문에, 만들지 않아도된다.(super())
  * 객체= 인스턴스 != 클래스(껍데기) 즉, 클래스를 불러와 객체로 명명해줬을때(생성자를 활용하든), 그것은 객체가 된다.(객체가 되어야 무언가 행위를  할수 있다. new를 사용해야 객체가 생성된 것이다. 그전까지는 클래스로 보면 된다.)
 # 4장(자바 변수 종류와 저장공간)
  * 지역변수(로컬), 매개변수(파라미터), 인스턴스 변수(클래스 내부에 있는 변수), 클래스(클래스 단위로 static으로 돌아다니는) 변수
  * 각 변수의 소멸위치
  * 지역변수(중괄호 내에서만 유효)
  * 매개 변수(메소드가 호출될때, 끝나면 소멸)
  * 인스턴스변수(객체가 생성될 때 생명 시작, 참조하고 있는 다른 객체가 없으면 소멸)
  * 클래스 변수(자바 프로그램이 끝나지 않으면 소멸되지 않음)
  * 다시 GC 개념(변수의 생명이 언제 끝나는지 기억)
  * 기본자료형(8개)
    * int
      * byte, bit
      * Byte의 맨 앞 공간이 0이면 양수, 1이면 음수 -> 양수 최대값 127, 음수 최대값 -128
      * 0000000은 0 10000000은 -128
    * short
      * 이것도 안쓰이는 것 같지만 작은 값을 표현할때는 쓰는게 좋다.
    * float (32) , double(64 bits)
      * 부동소수점이라고 IEEE 754에 명시되어있다.
    # 부동소수점은 무엇이며, 그에 따른 문제는?
     * BigDecimal 돈계산에서 쓰임
    * 참조 자료형
# 5장(자바 계산 및 연산자)
 * ++변수는 변수를 참조하기 전에, 1을 더한다.
 * 변수++는 변수를 참조하고 나서, 1을 더한다.
 * instanceof 연산자란? 10장에서 계속
 * Java 자료형 Short 크기는 2byte, Byte의 크기는 1byte이다. 이는 각각 8비트를 의미하고, 캐스팅 될때 127이었던 short는 -128로 변환된다. 앞의 1바이트가 버려지기 때문이다.
 * 소수형 타입은 비트연산이 불가능하다. 말그대로 "비트연산자"만 사용이 불가능한 것이며, 소수는 결국 부동소수점을 활용한 비트로 표현된다.(부동소수점이란?)

# 6장(조건)
 * 컴파일러는 세미콜론 ; 이 나올때까지 찾는다.
 * switch case 문에서는 case에 break를 달아주지않으면, 조건을 충족한 부분을 기준으로 그다음 break가 나올 때까지 모든 case가 실행된다.(따라서, break;를 추가하는 것을 항상 기억하자.)
 * continue;는 바로 다음 흐름으로 넘겨버린다.

# 7장(자료구조)
 * char의 default는 전부터 매우 궁금했었는데, "\u0000"은 cahr의 기본값이다.
 * null은 심지어 초기화 되어있지도 않은 상태값이다.
 * Collection? 배열과는 다르게 유동적으로 여러 데이터를 담을 수 있는 자료구조.

# 8장(참조 자료형)
 * this는 객체 변수와 매개 변수의 이름이 동일 할 때, 인스턴스의 변수를 구분하기 위해 사용됨.
 * **<U>메소드 오버로딩</U>** 이름이 같고 파라미터의 개수와 형이 같아도, 순서가 다르면 다른 메서드처럼 인식 -> 메소드 오버로딩은 같은 역할을 하는 메소드(같은 리턴)는 같은 이름을 가져야 한다는 개념이다!!
 * static은 객체를 생성하지 않아도됨(이유는 JVM static영역에 해당 객체가 생성되기 때문에.)
 * static의 위험성
 * pass by value, pass by reference -> 객체의 자료형에 대한 변화(pass by reference), local 변수의 변화(pass by value)

 # 9장(패키지와 접근제어자)
 * 패키지는 단순 폴더의 개념이 아니라, 컨벤션 규칙이 있다.(소문자, 예약어 불가 등)
 * import를 사용하여, 다른 패키지에 있는 클래스를 사용할 수 있음.
 * 접근제어자(클래스, 메소드, 인스턴스, 클래스 변수)
    * public - 누구나
    * protected - 같은 패키지
    * package-private - default 같은 패키지 내에서만
    * private 해당 클래스 내에서만 접근 가능
    * **Cal.java라는 자바 소스가 있는 경우, 그소스 내에 여러개의 클래스가 있을 수는 있지만, <U>public class는 1개 뿐이어야한다.(파일과 일치하는 이름으로)</U>**
 
# 10장(상속, 캐스팅, 다형성)
 * 상속이란?
   기존의 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의하는 것을 의미합니다.
   이러한 상속은 캡슐화, 추상화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나입니다.(출처 : http://www.tcpschool.com/java/java_inheritance_concept)
 * 보통 UML에서 **자식 -> 부모** 자식이 부모에 종속되어 있음을 표현함
 * 상속을 사용하는 이유는 재사용성이 대표적이다.(반복작업 제거)
 * 부모 클래스는 기본생성자 외에 상속을 위한, 작업을 할 필요가 없음
 * super는 자식클래스에서 부모클래스를 사용할때 default이며, 상위 생성자를 호출한다는 개념을 가지고 있다.
 * **<U>메소드 오버라이딩</U>** 접근제어자, 리턴 타입, 메소드 이름, 매개 변수 타입 및 개수가 모두 동일해야지만, 메소드 오버라이딩
    * Overriding은 다른 무엇보다 더 중요하고, 최우선시 된다.라는 뜻이다.
    * 메소드가 동일하게 선언되어 있다.는 **동일한 시그니쳐를 가진다.** 라고 표현된다.
    * 오버라이딩은 리턴 타입을 다르게 할 수 없다.
    * 오버라이딩은 접근제어자를 부모보다 축소해서 사용할 수 없다.
* **Overloading VS Overriding**
   * Overloading : 확장(메소드의 매개 변수들을 확장하기 때문에, 확장)
   * Overriding : 복제, 덮어 씀(부모 클래스의 메소드 시그니처를 복제해서 자식에서 부모 기능을 무시하고 덮어서 사용함.)
* 캐스팅(형변환)
   * 부모 = 부모, 자식은 가능하지만 자식 = 부모는 불가능하다. 더 넓은 범위로의 형변환만 가능
   * **다형성 :** 형변환을 하더라도, <U>실제 호출은 원래 겍체에 있는 메소드가 호출</U>된다. 
   * ArrayList를 보면, List가 implements 되어 있다. 사용되는 인터페이스의 구현체가 무엇인지 명시하지 않고 추상화를 통해 사용가능.
    * 더 나아가서 생각해보면, 객체를 선언할 때 뿐 아니라, 인터페이스를 통해 명시된 구현체를 몰라도 구현할 수 있도록 할 수 있다.

# 11장(API란?)
 * 재사용을 위해, 미리 만들어 놓은 클래스

# 12장(Object class)
 * 기본적으로 아무런 상속을 받지 않으면, Object클래스를 확장한다.( * Extends가 없으면 java는 Object를 확장한다.)
 * hashcode(16진수로 제공되는 객체의 메모리 주소)
 * toString() 자동 호출 point
    * System.out.println() 메소드에 메개 변수로 들어가는 경우
    * 객체에 대하여 더하기 연산을 하는 경우
    * Object 코드의 toString() ->  
       ```return getClass().getName() + "@" + Integer.toHexString(hashCode());```
    * toString()은 Overriding해 놓는 것이 좋다.
   * **Equals Overriding**
    * 같은 객체를 선언하면 주소값이 다르다. A(MemberDto(name)), B(MemberDto(name))
     * 그래서, 기존 Equals는 다르게 나온다. 따라서, Eqauls를 둘을 비교했을 때 내용이 같으면 같을 수 있도록 오버라이딩 해줘야한다.
     * ==를 사용하면, 객체의 주소가 다른 Hashcode를 비교하기에, 다르다고한다.
     * 그래서 보통 실무에서는 Equals가 같은 값이라면 Hashcode는 같은 값을 갖고 있어야한다. Object 명세(API문서)에 나와있다.(Effective java 3/E pg. 67)
       * 하지만, Equals가 다르다고 해서, Hashcode까지 다를 필요는 없다.(하지만, 이경우에 다른 hash값을 제공하면 hashtable 성능향상에 도움이 된다.)
       * 또한 이런 Overriding을 할 때, 쓰레드 안정성 까지 고려해야한다.
       * 이러한 제약들 때문에, Eqauls와 Hashcode를 직접 작성하는 것이 크게 권장되지는 않는다.

# 13장(인터페이스와 추상클래스, ENUM)
 * .class는 (class, interface, abstract) 3가지가 있다.
 * 일반적으로 시스템은 **분석 -> 설계 -> 개발 및 테스트 -> 시스템 릴리즈**로 이루어진다.
 * abstract, inteface의 장점
    * 기능을 구현하는 데에만 집중 가능
    * 개발자 역량에 따른 메소드의 이름과 매개 변수 선언의 격차를 줄일 수 있음
    * 선언과 구현을 구분할 수 있다.
 * **interface를 통해서만 다중상속이 가능하다.**
 * final
    * 클래스나, method final은 상속이 안되고 오버라이딩 안된다.
    * 기본 자료형 변수에서의 final은 그 변수는 더이상 바꿀 수 없다는 이야기다.(초기화도 반드시 필요하다.)
    * 참조 자료형 변수에서의 final은 해당 클래스가 final일 수 있으나, 인스턴스들은 final이 아닐 수 있다.
 * Enum
    * 상수의 집합.
    * Enum의 생성자는 public이 될 수 없다.
    * 호출 시에, 객체를 생성해주지 않아도 된다.
    * Enum의 단점은 상수의 변경이 필요한 경우, 프로그램을 중지해서 수정하고 다시 할당해야한다는 것이다.
    * Enum은 java.lang.enum을 상속받는다.
* 정리
   * 인터페이스, abstract는 클래스의 골격을 잡아주고 메소드를 선언해 놓을 때 유용하게 사용 가능.
   * Enum은 데이터나 상수를 처리할 때 사용하므로, 고정되어 있는 값을 처리할 때 사용

# 14장(예외)
 * try - catch는 짝이다.
 * finally는 반드시 실행되어야함.
 * Exception 3종류
    * checkedException : IOException, SQLException, MalformedURLException
    * error : 자바 외부의 디스크 다운같은 예외
    * runtime, unchecked Exception : nullpointer, clasCastException, IndexOutOfBoundsException
 * Exception의 할아버지 java.lang.Throwable
    * getMessage(), toString(), printStackTrace()
 * **예외처리전략**(토비의 스프링 3.1 pg.286)
    * 예외복구 : 재시도를 통해 예외 복구
    * 예외처리 회피 : 호출한 쪽에 예외의 로그를 출력하거나, 그대로 던짐
    * 예외 전환 : 호출한 쪽에 적절한 형태로 예외를 전환해서 던짐(실무에서 많이 써봄)

# 15장(String)
   * null체크는 우습게 볼 부분이 아니다. 많은 장애의 원인이기 때문에, 체크가 필요하다.(ex. isNull())
   * intern()이라는 메소드는 사용하면 안됨(시스템 심각한 저하 가능)
   * StringBuffer는 Thread safe하며, StringBuilder는 Thread Safe하지 않다.
   * JDK 5이상은 + 연산의 경우 컴파일 할때 해당 연산을 자동으로 StringBuilder로 변환해 준다.~~(한줄일때만 가능, 여러줄은 성능 문제)
     **<U>하지만, for 루프와 같이 반복 연산을 할 때에는 자동으로 변환해주지 않기 때문에 꼭 필요하다.</U>** -> 잘못된 정보, String에 대해 9.String에서 다시 정리했다.~~
   * StringBuilder, Buffer, String은 모두 CharSequence 타입으로 구현되어있어서, 매개변수로 받는 작업은 CharSequence가 권장된다.

 # 16장(클래스 안의 클래스 Nested Class)
  * static nested Class
     * static으로 구현된 nested Class
  * inner Class
     * static이 없는 경우
  * **Nested Class 필요 이유**
     * 캡슐화가 필요할때, 논리적으로 묶어서 처리하고 싶을때, 소스의 가독성 유지보수성을 높이고 싶을 때(오히려, 독이 될 수도 있다.)
  * 익명 클래스
     * 임시적으로 코드에 내부클래스를 구현하는 것. 람다식에서 많이 사용된다.

# 17장(어노테이션)
 * 컴파일러에게 정보를 알려주거나
 * 컴파일할 때와 설치 시의 작업을 지정하거나
 * 실행할 때 별도의 처리가 필요할 때.
 * SupressWarnings 얘는 내가 일부러 코딩한거니까 경고를 해 줄 필요가 없다.
 * Custom Annotation을 위하여 알아야 할 4가지
    * @Target(ElementType.Method) : 메서드에 적용하도록 선언한다.(클래스가 될수도, 변수가 될수도)
    * @Retention(RetentionPolicy.Runtime) : 런타임에만 정보가 유지되도록 한다.(Source -> 컴파일시, Class -> VM에서 사라짐. Runtime 실행시)
    * @Documented : 해당 어노테이션 정보가 javadocs문서에 포함된다는 것
    * @Inherited : 모든 자식 클래스에서 부모 클래스의 어노테이션을 사용 가능함.
   * 기본적으로 구현되어있는 어노테이션 3가지는 기억해두자.(Override, SuppressWarnings, Deprecated)

# 복습
 * instanceOf 연산자는 객체가 어떤 클래스인지, 어떤 클래스를 상속받았는지 확인하는데 사용하는 연산자
 * instanceOf는 구현체를 확인하겠다는 것인데, 다형성으로 대체될 수 있는 로직에서 사용한다면, 굳이 사용해야하는지 다시 한번 확인해봐야한다.
