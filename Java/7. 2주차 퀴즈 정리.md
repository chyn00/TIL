# 13장 인터페이스와 클래스
 * Interface vs Abstract
  * Interface는 변수나, 메서드의 내부 구현이 불가능하다.
  * Abstract와 Class의 차이점은 Abstract의 하위 클래스는 강제적으로 Method를 선언해야한다는 것이다. 원래 Class Class 사이의 상속은 강제로 선언하지는 않음.
  abstract클래스를 굳이 만드는 이유는, 인터페이스처럼 아예 빈것으로 두기도 애매하고, 어느정도 구현되어있는 클래스에서, 또 클래스를 만들기도 애매한 경우.
  * 또한, Abstract클래스는 인터페이스처럼 반드시 abstract로 되어있는 함수에 대해서는 오버라이딩해줘야한다.(추상 클래스 내부 메서드는 따로 가져다쓰면됨.)
  * Abstract클래스는 혼자 생성자 사용이 불가능함.(꼭 Abstract method가 오버라이딩 되어 출력되어야함.)

# 다형성
 * 많은 형태를 가질 수 있는 능력

# 동등성 vs 동일성
 * 동일성은 identity까지 같은 경우
 * 동등성은 Eqaulity가 같은 경우. 객체의 내용 필드나, 변수들이 일치하는지 확인하는 것.

# immutable vs final
 * final하다고 해서, immutable한 것은 아님. immutable은 메서드의 내부에 변경이 일어나지않도록 까지 고려해줘야함

# 상속을 사용하는 이유
 * 상속을 사용하지 않는다면, 어떤 추상화된 객체에 대한 사용법을 기본적으로 알 수가 없다.
 * 조금만 수정하고, 바꿔도 객체의 다양한 상속의 이점을 활용할 수 있다.
 * 추상화되어있는 객체가 같은 분류에 속해 있고, 하위 클래스를 만듦으로써, 재사용도 재사용이지만, 코드 수정시에도 연관된 코드를 다같이 수정해준다거나하는
   유지보수측의 장점도 있다.

# 상속 vs 합성
 * 상속에는 코드를 재사용하더라도, 부모 클래스와 자식클래스의 변경이 있는 경우 둘 다 수정을 하거나, 해줘야하는 번거로움이 존재한다.
 * 합성은 코드를 재사용할때, 변경 코드의 객체가 명확하기 때문에, 내가 사용하고있는 클래스에서 합성코드만 변경이 되어도 문제가 없다.
 따라서 다음 과 같은 결론이 나타난다.
 * 상속은 결합도가 높고, 합성은 결합도가 낮다.

# GC
 * new/young old 영역에서 new/young에서 일어나는 gc가 다르고 old로 갈수록 시간에 따라 변경되는 GC가 있다.
 * 시간에 따른 GC와 그냥 GC알고리즘은 다르다.
 * GC알고리즘이 시간에 따라 바뀌지는 않는다. 해당 JDK에서 사용하는 GC가 뭔지 확인해야한다.
 * 보통 GC 들은 eden -> survivor-> old -> permanent영역순으로 GC가 살아있는 객체들을 한개씩 제거하기 시작하는데,
   G1GC같은 경우에는 Region이라는 영역을 만들어서 제거하기 때문에, stop the world가 가장 적다.

# Static
 * static은 자바의 static 영역에 배치된다. 여기에 값이할당되지만, static class안에 있는 파라미터 값같은것은 static이 아니기 때문에,
  메서드 영역에 할당이 된다. 이영역은 none - heap 영역으로 none - heap영역은 gc가아닌 jvm의 메커니즘에 의해 관리된다.

# Hash code
 * **<U>Hash code는 공식문서에서, Equals가 동등한 객체라면, 같은 Integer를 return해줘야한다고 써있다.</U>**
 * hash code는 equlas와 hashcode에 나와있는 정책(자바 API 문서에 적혀있음)에 따라, 재정의 되어야하고, Equals메서드와 동일한 결과가 나와야한다.
 * 특히나, Eqauls는 재정의를 해줘야 ==연산자처럼 identity를 따지지 않고, 동등성을 따지게 되기 때문에, 해시코드도 이처럼 정의해줘야한다.

# 동시성 이슈
 * 동시성 이슈는 단순히 쓰레드에 걸리거나, 락으로 사용하는 것 뿐만아니라, 데이터 쪽에서 문제가 생길수도 있다.
 * 처리 순서에 따라, 개발자가 예상한 프로세스를 따라야하는데, 시스템에 동시에 접근하게 되면, 예상치 못한 흐름이 생기기 때문에 문제가 생긴다.
 * 쿼리로도 해결할 수 있고, Event driven과 같은 형식으로 해결할 수도 있다.
 * 동시성 이슈란. 정확히 동시에 한 데이터 혹은 쓰레드에서 흐름이 멈춰 무한 점유 상태가 되거나, 여러가지 값이 동시에 수정되어, 데이터가 예측하지 못하게 수정되는 경우가 있다.
  * 예시로, 회원가입이 max 100명인데, 105명이 동시에 허용되는 경우가 있을 수도 있고,
   * 경품 추첨의 경우 문제가 될수도 있다.(100명까지 밖에 없는데, 동시에 데이터에 접근할 수 있어서 쿠폰이 발급되는 경우.)

# 상수성이란??
 * 상수, 변하지 않는 수. 항상 같은 값을 유지

# JDK 17 default GC??
 * G1GC이며, 기본 힙구조에서의 사용과 다르게 Region이라는 영역으로 재할당 하여, 라이프사이클을 돌린다.
 * 큰 힙 사이즈에서 유리하다고 한다.

# 다형성
 * 객체(클래스)뿐만아니라, 요소들(메서드 등)이 여러가지 타입을 가질 수 있는 것.
 * 다형성을 사용하여, 상속을 사용하기도 하고, 추상화를 사용하기도 한다.
 * 다형성을 사용하면, 메시지로 객체의 선택이 가능하며, 심지어 그 객체를 사용자가 알지 못해도, 다형성 추상화된 개념만 이해하고 있으면 사용할 수 있다.(기본 자동차의 개념은 변하지 않음 -> 하지만 다양한 형태로 표현될 수 있음.)
 * 다형성은 고유한 개념이 변하지않지만, 그 객체나, 요소를 호출하는 곳이 여러가지 타입으로 해당 개념을 사용할 수 있는 것을 의미한다고 생각한다.