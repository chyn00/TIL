# 자료구조
 * Hash란?
  * Hash function을 사용해서 값을 저장한다.
   * hash는 map에만 있는것이아니다. hashset 등도 존재한다.
  * hash는 worst 케이스에서 O(N)의 시간복잡도를 가지며, 해시충돌이 일어날 때 이런 결과를 나타낸다.
   * open addressing, chaning등은 해시 충돌을 해결하는 방법이지만, 시간복잡도를 해결하는 방법은 아니다.
   * 조금이라도 줄이기 위해, 자바에서 노력은 한다.
 * 구현체를 트리로 바꿔서 생각하면 map의 구현체가 treemap이 될 수도있다.
  * worst케이스를 가정해서, 생각하면 tree가 훨씬 효율적일 수 있다. Log(N)의 시간복잡도를 유지하기 때문이다.
  * 트리는 기본적으로 정렬형태로 저장이된다. -> 바이너리 트리는 편향이 될 수 있어, 레드 블랙트리가 있다.

* 결론
 * 해시는 공간복잡도를 늘리면, 속도를 무한정 O(1)로 할 수는있다.
 * 공간복잡도, 시간복잡도의 효율성에 따라, trade-off를 거쳐 필요한 자료구조를 선택하는 개발자가 되자.

# Tree
 * 이진트리 : 밸런스를 맞춰주는알고리즘은 따로 없음
 * BST 바이너리 서치 트리 : (왼쪽, 오른쪽으로만 나눔)
 * 레드블랙 트리 : 무조건 한 노드를 기준으로 다른 노드가 2개가 형성이 됨. Log(N)의 시간 복잡도를 worst, best케이스에 다 사용함.
 * 그래서, 자바의 tree set treemap등은 모두 Red-black tree로 구현되어있다. BST는 최악이 N이기떄문이다.

* 우선순위 큐(힙)
 * 맥스 힙(max heap)은 루트 노드가 제일 크다.
 * 민 힙(min heap)은 루트 노드가 제일 작다.

# Array List vs LinkedList
 * Array list를 검색하는 경우의수
 * Linked List에서 검색되는 경우의수 
 * 같은 검색이더라도, 어떤 조건에서 더 빠르고 느린지 체크
 * 검색
  * Array List는 Index를 기반으로 하여, 인덱스를 알면, 접근이 O(1)이다. 하지만, 인덱스를 모르면 O(N)이다.
  * Linked List는 Index를 모른다. 해당 노드만 옆의 노드가 무엇인지 알아야하기 때문에, 검색속도가 O(N)이다.
 * 삽입
  * Array List는 값이 삽입 되면, index를 다시 재정렬해줘야하기 때문에, O(N)만큼 시간이 더 걸릴 수 밖에없다.
  * Linked List는 값이 삽입 되었을때, Link로 연결되어있기 때문에, 재정렬같은 시간이 소요되지않는다.
   * 하지만, 맨앞이나, 맨뒤에 삽입하는 시간복잡도는 같다고 볼 수 있다.
 * 삭제, 수정은 index를 기반으로 생각해보자. Index를 아는 경우에도 삭제를 하고 재정렬시간이 필요한 ArrayList는 느리다.
  * 하지만, LinkedList는 찾는데까지는 오래걸리지만, 삭제를 하면 재정렬을 하지않고, 링크만 끊으면 되기때문에, trade-off가있다.
  * array가 찾는데는 빠르다. 하지만 worst를 기준으로 하면 결국 데이터의 조작(삽입,삭제,수정)은 모두 LinkedList가 빠르며, Index를 모를때에는 ArrayList는 느리다.

 * 결론 배열을 리사이징 해야하는 ArrayList는 데이터가 작을때는 상관없지만, 조작이 필요한 경우, index를 모르는경우는 linked List와 다를바가 없다.
 * LinkedList는 저장공간을 차지하게 된다. 헤드의 정보 연결정보들이 필요하기 때문에, 이 트레이드 오프를 잘 생각해야한다.

 # Set은 순서가 없고 중복이 없는 자료구조이다.